
{% extends "data_collection/templates/base.html" %}
{% load static %}

{% block content %}
<h2>Add Farm for {{ farmer.first_name }} {{ farmer.last_name }}</h2>

<!-- Success/Error Message -->
<div id="message"></div>

<!-- Existing Farms List -->
<div class="card mb-4">
    <div class="card-header">
        <h3>Existing Farms</h3>
    </div>
    <div class="card-body">
        <div id="farmsList">
            <p>Loading existing farms...</p>
        </div>
    </div>
</div>

<!-- Farm Form -->
{% comment %} <form id="farmForm" method="post">
    {% csrf_token %}
    {{ form.as_p }}
    <input type="hidden" name="boundary" id="boundary">
    <button type="submit" class="btn btn-primary">Submit Farm</button>
    <!-- Button to Add Plantation Boundary -->
    <div class="mt-3">
        <button id="addPlantationBoundaryBtn" class="btn btn-success">üå± Add Plantation Boundary</button>
    </div>
</form> {% endcomment %}
<form id="farmForm" method="post" enctype="multipart/form-data">
    {% csrf_token %}
    
    <div class="mb-3">
        <label for="id_farm_name">Farm Name:</label>
        {{ form.farm_name }}
    </div>

    <div class="mb-3">
        <label for="id_area_in_acres">Area (in acres):</label>
        {{ form.area_in_acres }}
    </div>

    <div class="mb-3">
        <label for="id_ownership">Ownership:</label>
        {{ form.ownership }}
    </div>

    <!-- Leased Fields (Initially Hidden) -->
    <div id="leasedFields" style="display: none;">
        <div class="mb-3">
            <label for="id_owner_mobile_number">Owner Mobile Number:</label>
            {{ form.owner_mobile_number }}
        </div>

        <div class="mb-3">
            <label for="id_owner_full_name">Owner Full Name:</label>
            {{ form.owner_full_name }}
        </div>

        <div class="mb-3">
            <label for="id_landlord_declaration">Landlord Declaration </label>
            <input type="file" id="landlordDeclaration" name="landlord_declaration" accept="image/*" class="form-control">
        </div>
    </div>
            <!-- Land Ownership Document -->
    <div class="mb-3">
        <label class="form-label">Land Ownership Document </label>
        <input type="file" id="landOwnership" name="land_ownership" accept="image/*"   class="form-control">
    </div>
    <div class="mb-3">
        <label for="id_boundary_method">Boundary Method:</label>
        {{ form.boundary_method }}
    </div>

    <input type="hidden" name="boundary" id="boundary">
    <!-- Map Container -->
    <h3>Draw the Farm Boundary</h3>
    <div id="map" style="height: 400px;"></div>
    
   <!-- Submit Buttons -->
    <div class="d-grid gap-2 mt-3">
        <button type="submit" class="btn btn-success w-100" id="submitAndGoNext">Submit and Go Next</button>
        <button type="submit" class="btn btn-primary w-100" id="submitAndAddMore">Submit and Add More</button>
    </div>
    {% comment %} <div class="mt-3">
        <button id="addPlantationBoundaryBtn" class="btn btn-success">üå± Add Plantation Boundary</button>
    </div> {% endcomment %}
</form>

<!-- Leaflet & Leaflet Draw JS -->
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.3/dist/leaflet.css"/>
<script src="https://unpkg.com/leaflet@1.9.3/dist/leaflet.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css"/>
<script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js"></script>
<script>
    // Image compression function
    function compressImage(file, quality, maxWidth, callback) {
        const reader = new FileReader();
        reader.readAsDataURL(file);
        reader.onload = function(event) {
            const img = new Image();
            img.src = event.target.result;
            img.onload = function() {
                let width = img.width;
                let height = img.height;
                if (width > maxWidth) {
                    height = (maxWidth / width) * height;
                    width = maxWidth;
                }
                
                const canvas = document.createElement('canvas');
                canvas.width = width;
                canvas.height = height;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(img, 0, 0, width, height);
                
                canvas.toBlob(function(blob) {
                    const compressedFile = new File([blob], file.name, {
                        type: 'image/jpeg',
                        lastModified: Date.now()
                    });
                    callback(compressedFile);
                }, 'image/jpeg', quality);
            };
        };
    }

    // Apply compression to all image inputs
    document.querySelectorAll('input[type="file"][accept*="image"]').forEach(input => {
        input.addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;
            if (!file.type.startsWith('image/')) return;

            const label = this.previousElementSibling;
            const originalLabelText = label.textContent;
            label.textContent = `${originalLabelText} (Compressing...)`;

            compressImage(file, 0.6, 1280, (compressedFile) => {
                const dataTransfer = new DataTransfer();
                dataTransfer.items.add(compressedFile);
                this.files = dataTransfer.files;

                label.textContent = originalLabelText;
                console.log(`Compressed ${file.name} from ${Math.round(file.size/1024)}KB to ${Math.round(compressedFile.size/1024)}KB`);
            });
        });
    });
</script>
<script>
    document.addEventListener("DOMContentLoaded", function() {
        // Base map layers (unchanged)
        var streets = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '&copy; OpenStreetMap contributors',
            maxZoom: 22
        });
    
        var satellite = L.tileLayer('/tiles/s/{z}/{x}/{y}', {
            attribution: '&copy; Google Satellite',
            maxZoom: 22
        });
        
        var terrain = L.tileLayer('/tiles/p/{z}/{x}/{y}', {
            attribution: '&copy; Google Terrain',
            maxZoom: 22
        });
        
        var hybrid = L.tileLayer('/tiles/y/{z}/{x}/{y}', {
            attribution: '&copy; Google Hybrid',
            maxZoom: 22
        });
    
        var esri = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
            attribution: '&copy; Esri World Imagery',
            maxZoom: 22
        });
    
        // Overlay for Place Names & Boundaries
        var esriLabels = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/Reference/World_Boundaries_and_Places/MapServer/tile/{z}/{y}/{x}', {
            attribution: '&copy; Esri, HERE, Garmin',
            maxZoom: 22
        });
        
        var esriClarity = L.tileLayer(
            'https://clarity.maptiles.arcgis.com/arcgis/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
            attribution: '&copy; Esri, Maxar, Earthstar Geographics',
            maxZoom: 22
        });       
    
        // Map initialization
        var map = L.map('map', {
            center: [23.6157, 81.9195], 
            zoom: 6,
            maxZoom: 22,
            layers: hybrid
        });
    
        // Layer control to switch between different maps
        var baseMaps = {
            "Streets": streets,
            "Google Satellite": satellite,
            "Google Terrain": terrain,
            "Google Hybrid": hybrid,
            "Esri World Imagery": esri,
            "Esri Clarity": esriClarity
        };
    
        var overlayMaps = {
            "Place Names & Boundaries": esriLabels
        };
    
        L.control.layers(baseMaps, overlayMaps).addTo(map);
    
        // Feature group for existing farms
        var existingFarms = new L.FeatureGroup();
        map.addLayer(existingFarms);
    
        // Feature group for drawn items
        var drawnItems = new L.FeatureGroup();
        map.addLayer(drawnItems);
    
        // Get existing farms from API
        fetchExistingFarms();
    
        // Function to fetch existing farms
        function fetchExistingFarms() {
            fetch(`/api/farms/{{ farmer.id }}/`, {
                method: "GET",
                headers: { "X-Requested-With": "XMLHttpRequest" }
            })
            .then(response => response.json())
            .then(data => {
                // Clear existing farms
                existingFarms.clearLayers();
                
                // Display farms in the list
                let farmsListHtml = '';
                
                if (data.farms && data.farms.length > 0) {
                    farmsListHtml = '<ul class="list-group">';
                    
                    // Generate farm colors for consistency
                    const farmColors = {};
                    data.farms.forEach((farm, index) => {
                        // Generate colors based on index
                        const colors = ['#FF5733', '#33FF57', '#3357FF', '#F3FF33', '#FF33F3', '#33FFF3', '#FF8C33', '#8C33FF'];
                        farmColors[farm.id] = colors[index % colors.length];
                    });
                    
                    // Add farms to the list and map
                    data.farms.forEach(farm => {
                        const farmColor = farmColors[farm.id];
                        
                        // Add to HTML list
                        farmsListHtml += `
                            <li class="list-group-item d-flex justify-content-between align-items-center">
                                <div>
                                    <span class="badge bg-secondary" style="background-color: ${farmColor} !important;">&nbsp;</span>
                                    ${farm.farm_name}
                                </div>
                                <button class="btn btn-sm btn-outline-primary zoom-to-farm" data-farm-id="${farm.id}">
                                    Zoom to Farm
                                </button>
                            </li>
                        `;
                        
                        // Add boundary to map
                        try {
                            const geoJsonFeature = JSON.parse(farm.boundary);
                            const layer = L.geoJSON(geoJsonFeature, {
                                style: {
                                    color: farmColor,
                                    fillColor: farmColor,
                                    fillOpacity: 0.3,
                                    weight: 2
                                }
                            });
                            
                            layer.farmId = farm.id;
                            layer.farmName = farm.farm_name;
                            layer.boundary = geoJsonFeature;  // Store the GeoJSON for intersection checking
                            
                            // Add popup with farm name
                            layer.bindPopup(`<strong>${farm.farm_name}</strong>`);
                            
                            // Add to existing farms layer group
                            existingFarms.addLayer(layer);
                        } catch (e) {
                            console.error("Error parsing farm boundary:", e);
                        }
                    });
                    
                    farmsListHtml += '</ul>';
                    
                    // Fit map to show all farms
                    if (existingFarms.getLayers().length > 0) {
                        map.fitBounds(existingFarms.getBounds(), { padding: [50, 50] });
                    }
                } else {
                    farmsListHtml = '<p>No farms added yet. Draw a boundary and submit the form to add your first farm.</p>';
                }
                
                document.getElementById("farmsList").innerHTML = farmsListHtml;
                
                // Add event listeners to zoom buttons
                document.querySelectorAll('.zoom-to-farm').forEach(button => {
                    button.addEventListener('click', function() {
                        const farmId = parseInt(this.getAttribute('data-farm-id'));
                        zoomToFarm(farmId);
                    });
                });
            })
            .catch(error => {
                console.error("Error fetching farms:", error);
                document.getElementById("farmsList").innerHTML = '<p class="text-danger">Error loading farms. Please try refreshing the page.</p>';
            });
        }
        
        // Function to zoom to a specific farm
        function zoomToFarm(farmId) {
            existingFarms.eachLayer(layer => {
                if (layer.farmId === farmId) {
                    map.fitBounds(layer.getBounds());
                    layer.openPopup();
                }
            });
        }
        
        // Try to get the user's location
        if (navigator.geolocation) {
            navigator.geolocation.getCurrentPosition(
                function(position) {
                    var lat = position.coords.latitude;
                    var lng = position.coords.longitude;
    
                    // Set map view to user's location if no farms exist
                    if (existingFarms.getLayers().length === 0) {
                        map.setView([lat, lng], 14);
                    }
    
                    // Add marker at user's location
                    marker = L.marker([lat, lng]).addTo(map)
                        .bindPopup("Your Current Location").openPopup();
    
                    // Store lat/lng in hidden form fields if they exist
                    if (document.getElementById("latitude")) {
                        document.getElementById("latitude").value = lat;
                    }
                    if (document.getElementById("longitude")) {
                        document.getElementById("longitude").value = lng;
                    }
                },
                function(error) {
                    console.error("Geolocation error: " + error.message);
                }
            );
        } else {
            console.log("Geolocation is not supported by your browser.");
        }
    
        // Load Turf.js for polygon intersection checking
        var turfScript = document.createElement('script');
        turfScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/Turf.js/6.5.0/turf.min.js';
        document.head.appendChild(turfScript);
    
        // Create warning message element
        var warningContainer = document.createElement('div');
        warningContainer.id = 'intersection-warning';
        warningContainer.style.display = 'none';
        warningContainer.className = 'alert alert-danger mt-2';
        warningContainer.innerText = 'Warning: Farm boundary overlaps with an existing farm! Please redraw the boundary.';
        document.getElementById('map').parentNode.insertBefore(warningContainer, document.getElementById('map').nextSibling);
    
        var drawControl = new L.Control.Draw({
            edit: { featureGroup: drawnItems },
            draw: { 
                polygon: true,
                polyline: false,
                rectangle: true,
                circle: true,
                marker: false
            }
        });
        map.addControl(drawControl);
    
        // Function to check if polygons intersect
        function checkForIntersections(newPolygon) {
            // Make sure Turf.js is loaded
            if (typeof turf === 'undefined') {
                console.warn("Turf.js is not loaded yet. Skipping intersection check.");
                return false;
            }
    
            let hasIntersection = false;
            
            // Convert the new polygon to a Turf.js polygon
            let newTurfPolygon;
            try {
                newTurfPolygon = turf.polygon(newPolygon.coordinates);
            } catch (e) {
                console.error("Error converting new polygon to Turf.js format:", e);
                return false;
            }
    
            // Check against all existing farm boundaries
            existingFarms.eachLayer(existingLayer => {
                if (hasIntersection) return; // Skip if we already found an intersection
                
                if (existingLayer.boundary) {
                    try {
                        const existingTurfPolygon = turf.polygon(existingLayer.boundary.coordinates);
                        
                        // Check for intersection
                        const intersection = turf.booleanIntersects(newTurfPolygon, existingTurfPolygon);
                        
                        if (intersection) {
                            console.log(`Intersection detected with farm: ${existingLayer.farmName}`);
                            // Highlight the farm that intersects
                            existingLayer.setStyle({
                                color: 'red',
                                weight: 3,
                                fillOpacity: 0.4
                            });
                            existingLayer.openPopup();
                            hasIntersection = true;
                        } else {
                            // Reset style if previously highlighted
                            existingLayer.setStyle({
                                color: existingLayer.options.style.color,
                                weight: 2,
                                fillOpacity: 0.3
                            });
                        }
                    } catch (e) {
                        console.error("Error checking intersection:", e);
                    }
                }
            });
            
            return hasIntersection;
        }
    
        // Handle the drawn polygon
        map.on(L.Draw.Event.CREATED, function (event) {
            var layer = event.layer;
            
            // Convert to GeoJSON for validation
            let geoJSON = layer.toGeoJSON().geometry;
            
            // Check if this polygon intersects with any existing farms
            let intersects = checkForIntersections(geoJSON);
            
            if (intersects) {
                // Show warning
                document.getElementById('intersection-warning').style.display = 'block';
                
                // Add layer with red styling to indicate problem
                drawnItems.clearLayers();
                layer.setStyle({
                    color: 'red',
                    fillColor: '#ff6666',
                    fillOpacity: 0.4,
                    weight: 2
                });
                drawnItems.addLayer(layer);
                
                // Disable form submission
                document.getElementById('boundary').value = '';
                document.querySelector('#farmForm button[type="submit"]').disabled = true;
            } else {
                // Hide warning if previously shown
                document.getElementById('intersection-warning').style.display = 'none';
                
                // Add layer with normal styling
                drawnItems.clearLayers();
                drawnItems.addLayer(layer);
                
                // Store boundary and enable form submission
                document.getElementById('boundary').value = JSON.stringify(geoJSON);
                document.querySelector('#farmForm button[type="submit"]').disabled = false;
            }
        });
        
        // Clear warning when editing starts
        map.on(L.Draw.Event.DRAWSTART, function () {
            document.getElementById('intersection-warning').style.display = 'none';
        });

        const ownershipField = document.querySelector("#id_ownership");
        const leasedFieldsDiv = document.querySelector("#leasedFields");

        if (!ownershipField || !leasedFieldsDiv) {
            console.error("Ownership dropdown or leased fields div not found!");
            return;
        }

        function toggleLeasedFields() {
            if (ownershipField.value === "LEASED") {
                leasedFieldsDiv.style.display = "block";  // Show leased fields
            } else {
                leasedFieldsDiv.style.display = "none";  // Hide leased fields
            }
        }

        // Initialize on page load
        toggleLeasedFields();

    // Listen for changes in ownership dropdown
        ownershipField.addEventListener("change", toggleLeasedFields);
    });
    // AJAX Form Submission
    document.addEventListener("DOMContentLoaded", function () {
        const farmForm = document.getElementById("farmForm");
        const messageDiv = document.getElementById("message");
    
        // Function to handle form submission
        async function handleSubmit(event, action) {
            event.preventDefault();
    
            // Double-check that boundary exists
            if (!document.getElementById("boundary").value) {
                messageDiv.innerHTML = `
                    <div class="alert alert-danger">
                        Please draw a farm boundary on the map.
                    </div>
                `;
                return;
            }
    
            // Show loading message and hide the form
            farmForm.style.display = "none";
            messageDiv.innerHTML = `
                <div class="alert alert-info">
                    Uploading data, please wait...
                </div>
            `;
    
            try {
                // Gather form data
                const formData = new FormData(farmForm);
    
                // Send AJAX request with the farmer ID included in the URL
                const response = await fetch("{% url 'add_farm' farmer.id %}", {
                    method: "POST",
                    body: formData,
                    headers: { "X-Requested-With": "XMLHttpRequest" }
                });
    
                const data = await response.json();
    
                if (data.success) {
                    // Success message
                    messageDiv.innerHTML = `
                        <div class="alert alert-success mt-3">
                            <p>‚úÖ Farm created successfully!</p>
                        </div>
                    `;
    
                    // Perform action based on the button clicked
                    if (action === "goNext") {
                        proceedToPlantation(data.farmer_id || {{ farmer.id }});
                    } else if (action === "addMore") {
                        // Reload the page to reflect the newly added farm
                        location.reload();
                    }
                } else {
                    // Display error message
                    messageDiv.innerHTML = `
                        <div class="alert alert-danger">
                            Error: ${data.errors || "Unknown error"}
                        </div>
                    `;
                    farmForm.style.display = "block"; // Re-enable the form
                }
            } catch (error) {
                console.error("Error:", error);
                messageDiv.innerHTML = `
                    <div class="alert alert-danger">
                        An unexpected error occurred. Please try again.
                    </div>
                `;
                farmForm.style.display = "block"; // Re-enable the form
            }
        }
    
        // Attach event listeners for both buttons
        document.getElementById("submitAndGoNext").addEventListener("click", function (event) {
            handleSubmit(event, "goNext");
        });
    
        document.getElementById("submitAndAddMore").addEventListener("click", function (event) {
            handleSubmit(event, "addMore");
        });
    
        // Function to proceed to plantation
        function proceedToPlantation(farmerId) {
            if (!farmerId) {
                alert("‚ùå Farmer ID missing! Cannot proceed to plantation.");
                return;
            }
            window.location.href = `/add-plantation/${farmerId}/`;
        }
    });
</script>

{% endblock %}